<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CList: Style</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CList
   &#160;<span id="projectnumber">V2</span>
   </div>
   <div id="projectbrief">Réimplémentation de std::list</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Style </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Convention de noms:</p>
<ul>
<li>Ne pas préfixer les noms de classes par C.</li>
<li>Ne pas préfixer les noms des données membres par m_</li>
</ul>
<p>Le style de code est le style Allman, c'est a dire que:</p><ul>
<li>Toute accolade délimitant un bloc d'instructions est seule sur sa ligne.</li>
<li>Les lignes vides ne doivent pas contenir d'espaces.</li>
<li>Une ligne vide doit suivre une ou plusieurs déclarations succesives.</li>
</ul>
<p>Indentez avec des tabulations.</p>
<h1>Fonctionnalités du C++ </h1>
<h2>Mot clé auto</h2>
<p>Le mot clé auto doit être utilisé pour simplifier une déclaration, dont le type est long à taper, comme <code>std::vector&lt;string&gt;::const_iterator</code>, pour améliorer la lisibilité.</p>
<h2>Header</h2>
<p>Les fichiers headers doivent être dans le dossier include du projet, vous pourrez donc les inclure dans vos fichiers source en utilisant les &lt;&gt; Lorsque vous incluez des headers dans un fichier cpp, faites les inclusions dans cet ordre:</p><ul>
<li>Le header de la classe si applicable (A.hpp dans A.cpp par exemple)</li>
<li>Les headers standard</li>
<li>Les headers de bibliothèques tierces</li>
<li>Les headers du projet <h3>Protection de multi-inclusion</h3>
</li>
</ul>
<p>Pour empêcher un fichier header d'être inclut plusieurs fois, on vous a appris à définir des macros de compilation conditionnelles.</p>
<p>``` #ifndef <b>FILE_H</b> #define <b>FILE_H</b></p>
<p>#endif ``` Comme vous pouvez le voir, c'est long à taper, et force le préprocesseur à lire tout le fichier pour savoir quelle partie du code est affectée. Un autre problème qui peut survenir lorsque un projet grandit en taille, c'est la collision des noms, 2 headers avec le même nom peuvent se trouver dans différents répertoires, et empêcher l'inclusion de l'un. La méthode utilisé couramment pour contourner ce problème est de faire des macros plus longues, ce qui devient plus pénible. Aussi modifier le nom de fichier vous force aussi à modifier son contenu.</p>
<p><code>#ifndef __PATH_TO_FILE_H_</code> ...</p>
<p>Pour remédier à ces problèmes, utilisez <code>#pragma once</code> au début de vos headers, c'est plus court, plus rapide à gérer pour le préprocesseur et plus rapide à compiler.</p>
<p>Les puristes se plaindront que <code>#pragma once</code> n'est pas standard, et n'est pas supporté par un certain compilateur d'IBM qui n'a pas eu de mise à jour depuis presque 3 ans. Ces mêmes personnes déclarent des tableau de type C de taille variable.</p>
<p><em>Note:</em> Le 25 novembre, Alain Casali a distribué un header écrit par Floran Narenji ou #pragma once été utilisé, donc ya de bonnes chances qu'il soit autorisé.</p>
<h2>Déclarations anticipées</h2>
<p>Il peut arriver que des classes dépendent l'une sur l'autre pour leur définitions. La classe <a class="el" href="struct_a.html">A</a> utilise B comme argument a certaines de ses méthodes, et B utilise <a class="el" href="struct_a.html">A</a> comme argument a certaines de ses méthodes, la première initiative est d'inclure le header de B dans celui de <a class="el" href="struct_a.html">A</a> et le header de <a class="el" href="struct_a.html">A</a> dans celui de B</p>
<p>Cela crée une dépendance circulaire, qui va faire que lorsque vous compilerez <a class="el" href="struct_a.html">A</a>, B sera inclus, il essayera d'inclure <a class="el" href="struct_a.html">A</a>, mais échouera car <a class="el" href="struct_a.html">A</a> ne pourra pas être inclus à cause de , faisant que B ne pourra pas être défini, et fera échouer la compilation.</p>
<p>Pour éviter ce problème, vous devez utiliser des déclarations anticipées. C'est à dire que vous déclarez que la classe B existe avant de définir la classe <a class="el" href="struct_a.html">A</a>, et que vous inclurez le header B dans le .cpp de <a class="el" href="struct_a.html">A</a>.</p>
<p><code>class B;</code></p>
<p>Cela implique plusieurs choses. <a class="el" href="struct_a.html">A</a> ne doit pas hériter de B (Peu de chance que sa arrive, une dépendance circulaire voudrait dire que vous faite heriter <a class="el" href="struct_a.html">A</a> de B et B de <a class="el" href="struct_a.html">A</a>). Et <a class="el" href="struct_a.html">A</a> ne doit pas manipuler la classe B et ses membres dans son header. Ce qui interdit la définitions de méthodes dans la définition de classes.</p>
<p>Aussi, je vous invite (lire 'force') à utiliser les déclarations anticipées même lorsque il n'y a pas de dépendances circulaires à résoudre, car cela permet d'éviter d'inclure le header de B partout où <a class="el" href="struct_a.html">A</a> est nécessaire, réduisant le temps de compilation du code.</p>
<p>Les déclarations anticipées ne sont pas utilisable dans un contexte où vous avez besoin de connaître la définition d'une classe comme l'héritage ou le passage de valeur par copie. Vous ne pouvez donc que déclarer des pointeurs/références vers B dans le header de <a class="el" href="struct_a.html">A</a> par exemple.</p>
<h2>Inline</h2>
<p>La déclaration inline permet de remplacer un appel par le corps d'une fonction. En théorie. En pratique, les fonction déclarer inline le sont que si possible, une fonction virtuelle ne peut être inline, car elle doit pouvoir être référencée dans la table virtuelle des classes qui la manipule, ainsi que les fonction récursives, qui ont besoin de manipuler la pile d'appels, un peu dur quand il y en a plus. Lorsque sa marche, le code est dupliqué partout ou un appel est utilisé. Produisant de plus gros exécutables. C'est pour sa qu'on ne fera inline que des fonctions courtes. Les constructeurs et destructeurs peuvent, mais ne doivent pas être rendu inline, car ils appellent implicitement les constructeurs et destructeurs des membres.</p>
<p>Notez que lorsque vous définissez une méthode dans une définition de classe dans un header, elle est implicitement inline. Notez aussi que lorsque vous déclarer des classes génériques, vous êtes obligés de définir ses méthodes dans son header... Tirez en vos propres conclusions.</p>
<h2>Explicit</h2>
<p>Le mot clé <code>explicit</code> permet d'instancier une classe seulement si on a utiliser son constructeur explicitement. Prenons par exemple une classe <a class="el" href="struct_a.html">A</a> qui a un constructeur prenant en paramètre une string. Si ce constructeur n'est pas explicit, une fonction prenant un <a class="el" href="struct_a.html">A</a> en paramètre pourra aussi prendre une string en paramètre. Ça peut être pratique, mais c'est pas vraiment un comportement prévisible. On utilisera alors le mot clé explicit devant tout constructeur ne prenant qu'un seul paramètre en argument.</p>
<h2>Délégation de constructeurs</h2>
<p>Vous pouvez appeler des constructeurs dans des constructeurs d'une même classe. Prenons notre classe <a class="el" href="struct_a.html">A</a>, qui a un constructeur prenant un int en paramètre et un autre prenant une string.</p>
<p><code>A::A(string s) {...}</code> <code>A::A(int i) : <a class="el" href="struct_a.html">A</a>("abc") {...}</code></p>
<p>C'est légèrement diffèrent d'un argument par défaut vu que la routine d'initialisation change aussi.</p>
<h2>Struct et Class</h2>
<p>La différence entre struct et class en C++ est très fine. Elle ne concerne que la visibilité des membre par défaut. Ils sont private dans une class et public dans une struct. C'est tout. Une struct peut heriter d'une classe et une classe peut hériter d'une struct.</p>
<p>Mais par souci de sémantique, on utilisera struct pour définir des objets qui ne contiennent soit que des données, soit qui servent d'interface (purement abstraite), soit qui gardent des traits. Et non pas une combinaison de 2 ou plus.</p>
<h2>Arguments par défauts</h2>
<p>Les arguments par défaut ne doivent être utilisé que dans les constructeurs.</p>
<h2>Exceptions</h2>
<p>Les exceptions simplifie le modèle de traitement d'erreur en propageant des erreur d'exécutions vers le code appelant. En théorie. En pratique, les exceptions produisent des exécutables plus gros, et a un coût à l'exécution mémé si le code ne les mentionnent pas. Dans un langage qui gère automatiquement les ressources, dans un environnement managé, lorsque vous faites une action interdite, comme accéder a un index en dehors d'un tableau, une exception est levée, et vous pouvez obtenir une pile d'appels et de contextes qui aide a trouver des bugs.</p>
<p>Le C++ n'offre rien de tout ça, un code C++ dit "exception-safe" ne peut pas gérer les erreurs lors de la libération de ressources, et un code exception-unsafe provoquera des fuites de mémoire. Vous perdez aussi la pile d'appel et le contexte dans lequel l'exception c'est faite levée. Déréférencer un pointeur nul est littéralement plus pratique que de lancer une exception, au moins vous avez un coredump. Les exception du C++ sont incomparable a celles d'autre langages véritablement orientés objet. Lancer des exception dans un destructeur est dangereux, un constructeur doit se contenter d'initialiser les données, et doit faire le minimum de choses possible.</p>
<p>Les exceptions sont désactivé, un appel à throw est donc remplacé par un appel à std::terminate. Ajoutez le mot clé <code>noexcept</code> au profil de toute les methodes.</p>
<h2>Flux</h2>
<p>N'utilisez pas cout/cerr, ou des flux en général. Les flux sont plus lent, et sont moins flexible que printf pour ce qui est de formatter une sortie, ou de reordonner les arguments.</p>
<p>Par exemple, pour afficher un entier en héxadécimal, sous la forme 0xAABBCCDD, avec les 0 en tête:</p>
<p>`std::cout &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(8) &lt;&lt; x &lt;&lt; std::dec &lt;&lt; std::endl;`</p>
<p>contre</p>
<p><code>printf("0x%08xn\\n", x)</code></p>
<p>Version 0.1</p>
<h2>Entiers</h2>
<p>N'utilisez que int pour représenter un nombre entier quelconque. Si vous avez besoin d'une taille spécifique, utilisez les types fournis par stdint.h Le standard C++ ne spécifie pas exactement la taille des types entiers, seulement leurs capacités minimales. En pratique, sur les 3 OS principaux, un char fait 8 bits, un short fait 16 bits et un int fait 32 bit. Sur des systèmes type Unix, un long fait 64 bit, mais 32 bit sur Windows. Utilisez seulement int pour des compteurs ou des nombres dont vous savez qu'ils ne pourrons pas atteindre la limite. Sinon, utilisez int64_t.</p>
<h3>Entiers non-signés</h3>
<p>N'utilisez pas d'entiers non signés pour indiquer qu'une valeur ne peut être négative. Utilisez des assert à la place. Les entiers non-signés doivent être utilisé pour représenter des données brut ou des masques de bits.</p>
<p>Considérez cette boucle:</p>
<p><code>for (unsigned int i = foo.Length()-1; i &gt;= 0; --i)...</code></p>
<p>Ce genre de bug est typiquement introduit par l'emploi d'entier non-signés. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 7 2014 00:31:24 for CList by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
