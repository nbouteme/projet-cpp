<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CList: Aide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CList
   &#160;<span id="projectnumber">V2</span>
   </div>
   <div id="projectbrief">Réimplémentation de std::list</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Aide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Standard C++: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a></p>
<h1>Aide pour l'implementation </h1>
<p>node_iterator et node sont des classes génériques interne à List (declarez les a l'interieur de celle ci)</p>
<h2>Classe node</h2>
<p>La <code>struct node</code> contient simplement 2 pointeurs, vers les node suivant et precedant appelé next et prev. Elle contient aussi un objet de type T appelé data.</p>
<h2>Classe node_iterator</h2>
<p>Comme tout ses membre doivent etre public, on utilisera la mot cle struct pour la declarer</p>
<p>La classe node_iterator est une classe generique qui defini plusieurs types:</p><ul>
<li>difference_type</li>
<li>iterator_category</li>
<li>value_type</li>
<li>pointer</li>
<li>reference</li>
</ul>
<p>Elle possede un constructeur par defaut, qui initialize un pointeur vers struct node qui contient 2 pointeurs (next et previous, les elements suivant et precedent de la liste), Et un autre constructeur qui peut prendre en parametre un pointeur vers cette structure</p>
<p>Elle a pour seul membre un pointeur vers struct node, appelé node_ptr;</p>
<p>Ensuite, cette classe doit se comporter comme un iterateur normal, il faut donc surcharger les operateurs *, -&gt;, ++ et &ndash; (post et pre) et les operateur de comparaison == et &lt;. La classe const_node_iterator est une version const. La STL fourni des templates pour les reverse_iterator, sa devrait pas poser de probleme. Ces classes devrait etre implementer comme sous classes publique de List, ou bien comme classe a part entiere, a debattre.</p>
<p>Les iterateur se comporte a peu pres comme des pointeurs. Il est donc necessaire de surcharger les operateurs ++ &ndash;, que vous avez vu en cours, et l'operateur unaire * et -&gt;.</p>
<p>L'iterateur itere sur des objets du type T (generique), et avance et recule en utilisant les pointeur de la structure node (next et prev), par exemple, it++ passe a l'objet suivant de la liste.</p>
<p>La surcharge de l'operateur * doit renvoyer une reference a l'objet du noeud iteré (le membre data du noeud), pour pouvoir le modifier.</p>
<p>Utilise alors le typedef reference pour ecrire le profil:</p>
<p>reference operator*() noexcept;</p>
<p>Il est aussi necessaire d'ecrire une version const de la surcharge:</p>
<p>const reference operator*() const noexcept;</p>
<h2>Constructeur de List</h2>
<p>List possede un constructeur par defaut qui ne peut lever une exception que si le constructeur de la classe contenue dans la liste peut lever une exception. Cela sera implementer plus tard, pour l'instant ecriver des constructeur lambdas.</p>
<h2>Classe list</h2>
<p>Il est prevu a l'heure d'ecriture de ces ligne, d'implementer tout les membres present sur <a href="http://www.cplusplus.com/reference/list/list/">http://www.cplusplus.com/reference/list/list/</a> sauf ceux de la categorie Operation, et les midifier emplace* et assign, qui seront implemente apres les smart pointer</p>
<p>La classe list a pour seule donnee membre un base_node qui est la sentinelle de la liste, elle est initialisee dans le constructeur telle que son suivant et son precendent pointent vers lui meme La fonction size() recalcule a chaque appel la taille de la liste. Cela peut sembler lourd, mais quand il s'agit d'utiliser splice pour manipuler la liste, maintenir une variable de longueur est bien plus lourd, et de plus, tout les algorithme fonctionnant sur les type de conteneur liste chainee le traite de maniere sequentielle.</p>
<h3>operateur -&gt;</h3>
<p>L'operateur -&gt; renvoie l'adresse du membre sur lequel l'utilisateur veut recuperer un membre Par exemple, une classe <a class="el" href="struct_a.html">A</a> ayant pour membre b, une instance de B ayant elle pour membre a c et -&gt; surchargée dans <a class="el" href="struct_a.html">A</a>, une instance a de <a class="el" href="struct_a.html">A</a>, alors l permet d'acceder aux membre c de b en renvoyant un pointeur vers b</p>
<h2>swap</h2>
<p>Swap prend une reference vers une list, et echange leur sentinelle.</p>
<h2>resize</h2>
<p>Resize prend en parametre une taille de liste <em>n</em>, et une const value_type&amp; qui a comme valeur par defaut T() la fonction navigue jusqua n noeud et supprime les node de la jusque la fin de la liste. Si on atteint la fin de la liste avant d'avoir traverser n noeud, alors on ajoute (n - nombre de noeud traversé) en recopiant le second parametre</p>
<h2>splice</h2>
<p>splice sert a transferer des element d'une liste a l'autre, on va seulement implementer 3 de la surchage, autre surcharge, et certain constructeur peuvent alors etre implementer avec cette methode</p>
<h3>transfer</h3>
<p>pour implementer splice, on doit implementer transfer, qui prend en parametre 2 iterateur (first et last), indiquant une portion de liste, avec la borne inferieur incluse et la borne sup excluse. et la deplace avant lui meme. donc concretement il y a 7 operation:</p><ul>
<li>Le noeud suivant du noeud precedent de last devient celui qui a appelé transfer (this)</li>
<li>Le noeud suivant du noeud precedent de first devient last (permet de refermer la portion de liste dans un sens)</li>
<li>Le noeud suivant du noeud precedent du noeud qui a appeler transfer (this) devient first</li>
<li>Sauvegarder le noeud precedant de l'appelant (this)</li>
<li>Le noeud precedent de l'appelant devien le precedent de last</li>
<li>Le noeud precedent de last devient le precedent de first (referme la portion de la liste dans l'autre sens)</li>
<li>Le noeud precedent de first devient celui qui a ete sauvegardé plus haut, l'ancien noeud precedant de l'apelant</li>
</ul>
<p>La fonction ne doit rien faire si last pointe le meme noeud que le noeud appelant, puisque l'action est deja faite</p>
<h2>reverse</h2>
<p>la classe base node doit avoir une methode reverse qui sera appelee par la classe liste sur sa sentinelle elle doit sauvegarder un pointeur sur le noeud, puis dans une boucle, echanger (swap) son pointeur precedent et son suivant. vu que le noeud suivant devient le precedent, on itere dans la liste en l'assignant a son precedent</p>
<h2>unique</h2>
<p>Supprime les element identique consécutif. You should be able to solve that.</p>
<h2>sort</h2>
<p>sort doit etre implémentée specialement pour cette classe, on ne peut utiliser une fonction standard ou un tri basique qui requiert que la complexité soit constante O(1) pour l'acces au elements</p>
<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html">http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html</a> Implementez cet algo, remplacez dans votre tete null par "sentinelle"</p>
<h2>remove</h2>
<h2>remove_if</h2>
<p>J-Je peux vo-vous faire confiance la dessus, hein ?</p>
<h2>merge</h2>
<p>merge prend en parametre une liste triée !!! et la liste qui apelle merge doit l'etre aussi !!! Si l'une des deux n'est pas triée alors on a un comportement indefini Mais bon, c'est a l'utilisateur de trier la liste, donc sa nous concerne pas :^)</p>
<p>L'algorithme de merge est lineaire, et plutot simple a mettre en place.</p>
<p>Soit 2 liste, 1 2 3 4 5 6</p>
<p>Leur merge donne 1 2 3 4 5 6</p>
<p>1 1 2 2 4 4 et 3 3 5 5</p>
<p>donne 1 1 2 2 3 3 4 4 5 5 Les maillons contenant des element identiques gardent le meme ordre</p>
<p>Aussi, la liste passée en parametre est vidée, puisque tout ses element seront transferer</p>
<h2>assign</h2>
<p>Assign remplace le contenu d'une liste par celui d'une autre. Pour economiser des allocation de memoire et dellocation, on ne supprime que ce qui a en trop, et n'ajoute que ce qui manque. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 7 2014 00:31:24 for CList by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
